{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 개요\nIT 마케터가 고객사 분석부터 제안서 초안 작성까지 반복적·소모적 작업을 30분 내 자동화하여, 고부가가치 전략 수립에 집중하도록 돕는 SaaS 웹 서비스.\n\n## 2. 문제 정의\n- 제안서 리서치·초안 작성에 평균 4~6시간 소요  \n- 정보 수집·분석·카피라이팅 단계마다 수작업 의존  \n- 제안서 품질 편차로 수주 성공률 저하  \n- 시장에 IT 마케팅 특화 자동화 도구 부재\n\n## 3. 목표 및 지표\n- 1차 목표: 테스트 유저 설문(1~5점 척도)에서 유익함 4점 이상 획득  \n- 2차 목표: 제품 출시 후 최종 초안까지 완료 및 응답한 사용자의 비율이 5% 이상\n- 성공 지표  \n  - 평균 작성 시간 ≤ 30분  \n  - 사용자 월간 활성 비율(MAU) ≥ 60%  \n  - 초안 품질 만족도(NPS) ≥ 40  \n  - 수주율 기여도 사용자 설문 20%↑\n\n## 4. 대상 사용자\n### 주요 사용자\n- IT 솔루션·에이전시 소속 마케터 (25~40세, 업무경력 1~8년)\n- 니즈: 빠른 고객사 분석, 설득력 있는 제안서, 반복 업무 최소화\n### 2차 이해관계자\n- 팀 리더·영업 담당자: 품질 관리, 수주율 향상\n- 경영진: 생산성·매출 상승\n\n## 5. 사용자 스토리\n- “IT 마케터로서 고객사 URL만 입력해도 핵심 정보가 정리된 리포트를 받고 싶다.”\n- “RFP 텍스트를 붙여넣어 최적 전략과 메시지를 추천받고 싶다.”\n- “AI가 만든 초안을 전체 검토 후 수정 지점을 빠르게 지시하고 싶다.”\n- “팀원과 초안 버전을 공유·협업해 한 번에 승인받고 싶다.”\n\n## 6. 기능 요구사항\n### 핵심 기능\n0. 사용자 온보딩 설문\n   - 입력: 마케터의 주요 업무 유형(신규/기존 고객, 산업군), 제안서 목적(신규 영업/업셀링/경쟁사 대응 등), 선호 문체, 협업 방식 등 간략 설문\n   - 출력: 맞춤형 분석 리포트·전략 추천을 위한 사용자 프로파일 데이터\n   - 수용 기준: 2분 내 설문 완료율 80% 이상, 설문 응답 기반 추천 정확도 사용자 평가 4/5 이상\n1. AI 고객사 분석  \n   - 입력: URL 또는 기업명  \n   - 출력: 산업(업종), 기업규모(매출/직원 수), 시장 성장률, 주요 기술스택, 대표 서비스/제품, 주요 경쟁사, 최근 주요 프로젝트, IT 투자 현황, 디지털 마케팅 채널/성과, 잠재 니즈 및 Pain Point 등 IT 마케터가 실제 제안서 작성에 참고하는 핵심 정보 리포트\n   - 수용 기준: 평균 60초 이내, 정확도 사용자 평가 4/5 이상\n2. AI 포지셔닝 & 전략 추천  \n   - 입력: 고객사 리포트, RFP 주요 요구  \n   - 출력: 차별화 포지셔닝, KPI, 캠페인 제안 3안  \n   - 수용 기준: 사용자 선택률 상위안 70% 이상\n3. 제안서 초안 생성  \n   - 입력: 선택한 전략·메시지  \n   - 출력: 목차, Executive Summary, 타임라인, 예산안, CTA  \n   - 수용 기준: 템플릿 적용, 5분 내 렌더링\n4. 인터랙티브 편집  \n   - 각 섹션별로 AI 채팅 인터페이스를 통해 수정 요청(리라이트, 톤/길이/포맷 등)을 대화로 수행, 변경 전/후 비교 미리보기 제공\n5. 버전·협업 관리  \n   - 저장, 이력 추적, 주석, 팀 공유 링크\n\n### 보조 기능\n- 템플릿 라이브러리(산업·목적별)  \n- 결과물 PDF·PPT·Google Slides 내보내기  \n- 워크스페이스 다중 프로젝트 관리  \n- 기본 CRM 통합(클라이언트 정보 자동 불러오기)\n\n## 7. 비기능 요구사항\n- 성능: 주요 API 응답 ≤ 3초, 초안 렌더링 ≤ 5분  \n- 보안: OAuth2, RBAC, 데이터 암호화(AES-256)  \n- 사용성: 온보딩 5분 이내, NPS ≥ 40  \n- 확장성: 동시 사용자 10,000명, 모듈러 아키텍처  \n- 호환성: 최신 Chrome, Edge, Safari, Firefox\n\n## 8. 기술 고려사항\n- 프런트엔드: Next.js 15.1.0 (App Router), React 19.0.0, TypeScript, Tailwind CSS, shadcn-ui, Framer Motion, Lucide React, next-themes\n- 백엔드: Supabase(PostgreSQL, Auth), Edge Functions\n- AI 엔진: OpenAI GPT-4 API, embeddings + RAG\n- 크롤링: serverless scraper, Clearbit/Crunchbase API\n- 인프라: Vercel(Serverless), Cloudflare CDN\n- 엔드포인트 모니터링: Sentry, Grafana\n- 데이터: 제안서·분석 리포트 JSON 저장, 버전 관리 테이블\n- 상태관리: Zustand (전역 상태), @tanstack/react-query (서버 상태)\n- 폼 및 검증: React Hook Form, Zod, @hookform/resolvers\n- 유틸리티: es-toolkit, date-fns, ts-pattern, react-use, clsx, class-variance-authority\n- HTTP 클라이언트: Axios\n- 개발 도구: ESLint, PostCSS, Autoprefixer, tailwind-merge, tailwindcss-animate, @tailwindcss/typography\n\n## 9. 성공 측정\n- 평균 작성 시간 로그 분석  \n- 신규 가입→활성 전환율 ≥ 40%  \n- 리포트 정확도 피드백 점수 ≥ 4/5  \n- 초안 내 CTA 클릭률(내보내기 후 추적)  \n- 월 결제 유지율 ≥ 85%\n\n## 10. 일정 및 마일스톤\n| 단계 | 기간 | 주요 산출물 |\n|---|---|---|\n| Phase 1 – MVP | 0~3개월 | 고객사 분석, 초안 생성, 단일 템플릿 |\n| Phase 2 – 개선 | 4~6개월 | 전략 추천 다중안, 편집 UX, PDF/PPT 내보내기 |\n| Phase 3 – 확장 | 7~9개월 | 협업·버전관리, CRM 통합, 템플릿 스토어 |\n\n## 11. 리스크 및 대응\n- AI 출력 품질 저하 → RAG, 사용자 피드백 루프, 프롬프트 튜닝  \n- 크롤링 차단 → 공신력 API 대체, 캐시 전략  \n- 개인정보 이슈 → PII 마스킹, 로컬 암호화  \n- 시장 경쟁 가열 → IT 마케팅 특화 포지셔닝, 빠른 기능 릴리즈\n\n## 12. 향후 계획\n- 자동 견적 및 전자서명 모듈 추가  \n- 다국어 제안서(EN/JP) 지원  \n- 세일즈 인텔리전스 API 확장  \n- AI 음성 프레젠테이션 생성  \n- 마켓플레이스(디자이너·카피라이터) 연동",
      "writedAt": "2025-07-07T14:20:03.893Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구 사항 문서 (TRD)\n\n## 1. 기술 총괄 요약\n- **프로젝트 개요**  \n  IT 마케터용 제안서 자동화 SaaS를 Next.js 기반 SPA/SSR 혼합 아키텍처와 Supabase 백엔드를 활용하여 30분 내 초안 작성을 지원하는 웹 애플리케이션으로 구축한다. 모든 서버리스·매니지드 서비스를 적극 활용해 팀 규모 대비 운영‧배포 부담을 최소화한다.\n\n- **핵심 기술 스택**  \n  Frontend: Next.js 15 (App Router) + React 19 + TypeScript + Tailwind CSS  \n  Backend: Supabase(PostgreSQL, Edge Functions) + OpenAI GPT-4 API + Clearbit/Crunchbase API  \n  Infra: Vercel(Serverless) + Cloudflare CDN + Sentry/Grafana\n\n- **주요 기술 목표**  \n  1. AI 리포트 평균 응답 ≤ 3초, 초안 렌더링 ≤ 5분  \n  2. 동시 접속 10,000명까지 성능 저하 없이 확장  \n  3. OAuth2·RBAC·AES-256 암호화로 개인정보 및 결제 정보 보호  \n  4. 99.9% 가용성, 장애 복구 RTO 30분 / RPO 5분\n\n- **핵심 가정**  \n  - 초기 사용자는 수천 명 수준이며 서버리스 과금으로 비용 효율성을 확보한다.  \n  - AI 모델 호출 비용은 RAG 캐싱과 프롬프트 최적화로 월 예산 내 관리 가능하다.  \n  - Supabase가 제공하는 인증·DB·스토리지를 활용해 별도 서버 유지보수를 최소화한다.\n\n---\n\n## 2. 기술 스택 아키텍처\n\n### 프런트엔드 스택\n- **코어 프레임워크**: Next.js 15.1.0 (React 19, TypeScript 5.x, App Router)  \n- **상태 관리**: Zustand(전역) + @tanstack/react-query(서버 상태)  \n- **라우팅**: Next.js App Router (파일 기반·동적 경로)  \n- **UI/UX**: Tailwind CSS + shadcn-ui + Framer Motion + Lucide React + next-themes  \n- **빌드 도구**: Vercel 빌드, Turbopack, ESLint, Prettier, PostCSS, tailwind-merge\n\n### 백엔드 스택\n- **런타임**: Node.js 20 (V8) on Vercel Edge Functions  \n- **웹 프레임워크**: Supabase Edge Functions (Deno) + Hono (경량 미들웨어)  \n- **API 디자인**: RESTful JSON (OpenAPI 3.1 스펙 문서화)  \n- **데이터 검증**: Zod 스키마, class-validator (DTO 레이어)  \n- **미들웨어**: JWT 검증, rate-limiting, Sentry 트레이싱, CORS, 압축\n\n### 데이터베이스 & 영속 계층\n- **주 데이터베이스**: Supabase PostgreSQL (Managed)  \n- **스키마 설계**: 3정규형 + JSONB(유연 필드) 조합, 다중 테넌시용 `workspace_id` 파티셔닝  \n- **캐시 전략**: Redis@Upstash (RAG 임베딩, 세션, AI 응답 캐싱)  \n- **마이그레이션**: Supabase Migrations CLI (SQL) + GitHub Actions 자동 적용  \n- **백업·복구**: Supabase Point-in-Time Recovery, 주 1회 스냅샷, S3 오프사이트 백업\n\n### 인프라 & DevOps\n- **호스팅**: Vercel(Serverless Functions·Edge), Supabase Cloud, Cloudflare CDN/Zero-Trust  \n- **컨테이너화**: 불필요(서버리스), 필요 시 Docker 로컬 개발만 지원  \n- **CI/CD**: GitHub Actions → Vercel Preview/Production 자동 배포, Supabase DB Diff 적용  \n- **모니터링·가시성**: Vercel Analytics, Grafana Cloud(Tempo/Loki), Sentry APM  \n- **로그 전략**: Supabase & Vercel 로그 → Grafana Loki 중앙 집계, 30일 보존\n\n---\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 빌딩 블록\n- 프런트엔드 Next.js 앱 (CSR + SSR 혼합)  \n  - 온보딩/대시보드/에디터/설정 모듈  \n- 백엔드 API (Supabase Edge Functions)  \n  - 인증·RBAC, AI 라우터, 데이터 CRUD, 결제 Webhook  \n- AI 모듈  \n  - GPT-4 호출, embeddings 저장, RAG 검색, 프롬프트 템플릿  \n- 데이터베이스 레이어  \n  - PostgreSQL 테이블·뷰, 정책(RLS), Row-Level 보호  \n- 외부 통합  \n  - Clearbit/Crunchbase, Stripe, OAuth 소셜, Cloudflare Turnstile\n\n### 최상위 컴포넌트 상호 작용 다이어그램\n```mermaid\ngraph TD\n    A[Next.js Client] -->|HTTPS| B[Supabase Edge Functions]\n    B -->|SQL| C[PostgreSQL]\n    B -->|gRPC HTTP| D[OpenAI API]\n    C --> E[Upstash Redis]\n    B -->|Webhook| F[Stripe]\n```\n- 클라이언트는 Edge Functions REST 엔드포인트를 호출해 데이터·AI 요청을 처리한다.  \n- Edge Functions는 Postgres RLS 정책을 적용하여 안전하게 CRUD를 수행한다.  \n- AI 요청은 OpenAI API로 프록시하며 결과·임베딩을 Redis에 캐시한다.  \n- 결제 이벤트는 Stripe Webhook으로 수신, 사용권·요금제 테이블에 반영한다.\n\n### 코드 구성 & 컨벤션\n\n**도메인 중심 조직 전략**\n- 사용자, 워크스페이스, 프로젝트, AI, 결제 등 도메인별 디렉터리 분리  \n- presentation → application → domain → infrastructure 4계층 패턴 적용  \n- 공통 타입·훅·UI 컴포넌트는 `shared` 모듈에 집중 관리\n\n**공통 폴더 구조**\n```\n/project-root\n├── frontend/\n│   ├── src/\n│   │   ├── app/               # Next.js App Router\n│   │   ├── domains/\n│   │   │   ├── auth/\n│   │   │   ├── proposal/\n│   │   │   ├── workspace/\n│   │   │   └── payment/\n│   │   ├── components/\n│   │   ├── hooks/\n│   │   ├── services/          # API client\n│   │   ├── stores/            # Zustand\n│   │   └── utils/\n│   └── package.json\n├── backend/\n│   ├── functions/\n│   │   ├── auth/\n│   │   ├── ai/\n│   │   ├── proposal/\n│   │   ├── payment/\n│   │   └── utils/\n│   └── supabase.toml\n├── database/\n│   ├── migrations/\n│   ├── seeds/\n│   └── schema.sql\n└── infrastructure/\n    ├── github-actions/\n    ├── scripts/\n    └── monitoring/\n```\n\n### 데이터 플로우 & 통신 패턴\n- **클라이언트 ↔ 서버**: RESTful JSON, SWR 캐싱, react-query 옵티미스틱 업데이트  \n- **DB 상호작용**: Edge Function → Postgres via Supabase client, Row-Level Security  \n- **외부 API**: Server-side fetch with retry, circuit-breaker, typed response mapping  \n- **실시간**: Supabase Realtime WebSocket으로 협업 편집 presence 기능 구현 예정  \n- **데이터 동기화**: react-query + Supabase hooks로 클라이언트 캐시 일관성 유지\n\n---\n\n## 4. 성능 및 최적화 전략\n- RAG 검색 결과와 AI 응답을 Redis TTL 24h 캐싱, 동일 쿼리 재사용  \n- Next.js App Router의 `server-components`로 초기 데이터 SSR, 나머지는 ISR 캐싱  \n- 이미지·정적 자산은 Vercel Edge Cache + Cloudflare CDN으로 오프로드  \n- Database: 인덱스 설계, `pgvector` 임베딩 컬럼 ANN 인덱스, 비동기 Batch upsert\n\n---\n\n## 5. 구현 로드맵 & 마일스톤\n\n### Phase 1: Foundation (0~3개월)\n- **코어 인프라**: Vercel 프로젝트, Supabase 인스턴스, 기본 CI/CD  \n- **핵심 기능**: 온보딩 설문, 고객사 분석, 단일 템플릿 초안 생성  \n- **보안**: OAuth2 소셜 로그인, RLS, HTTPS 강제  \n- **개발 환경**: Storybook, Husky pre-commit, 기본 테스트 셋업  \n- **타임라인**: M1 완료 후 사용자 피드백 2주 수렴\n\n### Phase 2: Feature Enhancement (4~6개월)\n- **고급 기능**: 전략 추천 다중안, 인터랙티브 편집, PDF/PPT 내보내기  \n- **성능 최적화**: Redis 캐시, 가변 컨커런시 제어, AI 비용 관리  \n- **보안 강화**: 2FA, 조직별 RBAC, SSO 준비  \n- **모니터링**: Grafana 대시보드, Alertmanager 슬랙 연동  \n- **타임라인**: Phase 2 종료 시 공개 베타\n\n### Phase 3: Scaling & Optimization (7~9개월)\n- **스케일 아웃**: Supabase 읽기 복제, Edge Region 확장  \n- **고급 통합**: CRM 연동, 템플릿 마켓플레이스, Stripe Billing 퍼 블록  \n- **엔터프라이즈**: 감사 로그, 데이터 지역화 옵션, SLA 99.9%  \n- **컴플라이언스**: GDPR/CCPA 대응, 정기 Pen-Test  \n- **타임라인**: 정식 출시 및 마케팅 캠페인 개시\n\n---\n\n## 6. 리스크 평가 및 완화 전략\n\n### 기술 리스크\n| 리스크 | 설명 | 완화 방안 |\n| --- | --- | --- |\n| AI 품질 변동 | GPT-4 모델 업데이트 시 성능 저하 가능 | 프롬프트 A/B, 벤더 다중화(OpenAI, Anthropic), RAG 캐시 |\n| 크롤링 차단 | 고객사 웹 차단으로 데이터 부족 | Clearbit/Crunchbase API 백업, 캐시 저장 |\n| 성능 병목 | 동시 요청 급증 시 Edge 콜드스타트 | 프리웨밍, Redis 큐, 미리 렌더링 |\n| 보안 취약점 | PII·결제 데이터 유출 가능 | AES-256 at rest, Vault 키 관리, 정기 취약점 스캔 |\n\n### 프로젝트 전달 리스크\n| 리스크 | 설명 | 대응 |\n| --- | --- | --- |\n| 일정 지연 | 외부 API 한도 또는 인력 부족 | 기능 우선순위 재조정, 범위 축소 |\n| 리소스 부족 | AI 비용 초과 | 토큰 최적화, 요금제 조정 |\n| 품질 저하 | 테스트 커버리지 부족 | CI 테스트 게이트, QA 스프린트 |\n| 배포 사고 | 잘못된 마이그레이션 | Blue-Green 배포, DB 롤백 스크립트 |\n\n---\n\n끝.",
      "writedAt": "2025-07-07T14:20:03.894Z"
    },
    {
      "type": "guideline",
      "content": "# Project Code Guideline\n\n## 1. Project Overview\n\nThis project is an AI-powered SaaS web application for IT marketers, built to automate client analysis and proposal drafting within 30 minutes. The technical stack is centered on Next.js 15.1.0 (App Router) with React 19, TypeScript, Tailwind CSS, Zustand, and shadcn-ui for the frontend; Supabase (PostgreSQL, Auth, Edge Functions), OpenAI GPT-4 API, and Redis@Upstash for the backend. The architecture is modular, domain-oriented, and serverless-first, leveraging Vercel, Cloudflare CDN, and managed services for scalability, security, and operational efficiency. The system enforces strict API security (OAuth2, RBAC, AES-256), modular code organization, and robust CI/CD (GitHub Actions, Vercel).\n\n## 2. Core Principles\n\n1. **Domain-Driven Modularity:** All code MUST be organized by business domain and follow single responsibility per module.\n2. **Type Safety:** All code MUST be fully typed using TypeScript or schema validation, with no implicit any or unchecked types.\n3. **Explicit Error Handling:** All asynchronous logic MUST handle errors explicitly and propagate or log meaningful messages.\n4. **Security by Default:** Sensitive data MUST be encrypted and access controlled at all layers, with no hardcoded secrets.\n5. **Performance First:** All data access and API calls MUST be optimized for latency and concurrency, leveraging caching and batching where possible.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. TypeScript & React (Frontend)\n\n#### File Organization & Directory Structure\n\n- MUST follow domain-first organization under `/src/domains/[domain]`.\n- Shared components, hooks, and utilities MUST reside in `/src/components`, `/src/hooks`, `/src/utils`.\n- Pages and routes MUST be defined in `/src/app` using Next.js App Router conventions.\n\n```typescript\n// MUST: Example directory structure\n/src\n  /domains\n    /proposal\n      ProposalEditor.tsx\n      useProposal.ts\n      proposalService.ts\n  /components\n    Button.tsx\n    Modal.tsx\n  /hooks\n    useAuth.ts\n  /utils\n    formatDate.ts\n```\n\n#### Import/Dependency Management\n\n- MUST use absolute imports via `tsconfig` paths (e.g., `import { Button } from 'components/Button'`).\n- MUST group external before internal imports.\n- MUST NOT use deep relative imports (e.g., `../../../utils`).\n\n```typescript\n// MUST: Absolute import\nimport { Button } from 'components/Button';\n// Correct grouping\nimport { useQuery } from '@tanstack/react-query';\nimport { fetchProposal } from 'domains/proposal/proposalService';\n```\n\n```typescript\n// MUST NOT: Deep relative import\nimport { formatDate } from '../../../../utils/formatDate';\n// Use absolute path instead\n```\n\n#### Error Handling Patterns\n\n- MUST wrap all async calls in try/catch and handle errors gracefully.\n- MUST provide user feedback for recoverable errors via UI.\n- MUST log errors to Sentry using the provided SDK.\n\n```typescript\n// MUST: Error handling with Sentry\nimport * as Sentry from '@sentry/nextjs';\n\nasync function fetchData() {\n  try {\n    const data = await api.getData();\n    return data;\n  } catch (error) {\n    Sentry.captureException(error);\n    throw new Error('Failed to fetch data');\n  }\n}\n```\n\n### 3.2. Supabase Edge Functions (Backend)\n\n#### File Organization & Directory Structure\n\n- MUST separate functions by domain (`/functions/auth`, `/functions/ai`, etc.).\n- Shared logic MUST be placed in `/functions/utils` or extracted packages.\n- Each function MUST have its own entry point and handler.\n\n```typescript\n// MUST: Edge Function structure\n/functions\n  /ai\n    index.ts\n    aiService.ts\n  /auth\n    index.ts\n    authService.ts\n  /utils\n    errorHandler.ts\n```\n\n#### Import/Dependency Management\n\n- MUST use ES module syntax.\n- MUST NOT import unused dependencies.\n- MUST keep function cold start minimal by importing only necessary modules.\n\n```typescript\n// MUST: Minimal import\nimport { Hono } from 'hono';\nimport { validateUser } from '../utils/authService';\n```\n\n#### Error Handling Patterns\n\n- MUST standardize API error responses using a consistent JSON format.\n- MUST log server errors to Sentry.\n- MUST NOT leak stack traces or internal errors to clients.\n\n```typescript\n// MUST: API error response\nreturn c.json({ error: 'Unauthorized' }, 401);\n```\n\n```typescript\n// MUST NOT: Leak stack trace\nreturn c.json({ error: error.stack }, 500);\n// Instead, return a generic error\n```\n\n### 3.3. SQL (Supabase/PostgreSQL)\n\n#### File Organization\n\n- MUST keep all schema and migration scripts in `/database/migrations`.\n- MUST use Supabase Migrations CLI for schema changes.\n- MUST version control all migration files.\n\n```sql\n-- MUST: Migration file naming\n20240601_create_proposals_table.sql\n```\n\n#### Error Handling\n\n- MUST use database constraints (NOT NULL, UNIQUE, FK) for data integrity.\n- MUST check affected rows for all update/delete operations.\n\n## 4. Code Style Rules\n\n### MUST Follow\n\n1. **Single Responsibility per File/Component**\n   - Each file/component MUST implement only one logical concern or UI element.\n   - *Rationale:* Improves testability and maintainability.\n\n```typescript\n// MUST: Single responsibility\nfunction ProposalSummary({ summary }: { summary: string }) {\n  return <div>{summary}</div>;\n}\n```\n\n2. **Strict Type Annotations**\n   - All function parameters and return types MUST be explicitly typed.\n   - *Rationale:* Prevents runtime errors and enforces contract clarity.\n\n```typescript\n// MUST: Explicit types\nfunction getProposal(id: string): Promise<Proposal> { ... }\n```\n\n3. **Consistent Naming Conventions**\n   - MUST use camelCase for variables/functions, PascalCase for components/classes, UPPER_SNAKE_CASE for constants.\n   - *Rationale:* Enhances code readability and consistency.\n\n```typescript\n// MUST: Naming conventions\nconst API_URL = '...';\nfunction fetchUserData() { ... }\nclass ProposalEditor { ... }\n```\n\n4. **React Functional Components Only**\n   - MUST use function components and hooks; class components are prohibited.\n   - *Rationale:* Aligns with React 19 best practices and hooks ecosystem.\n\n5. **Tailwind Utility-First Styling**\n   - MUST use Tailwind CSS classes for all styling.\n   - *Rationale:* Ensures design consistency and eliminates CSS conflicts.\n\n```typescript\n// MUST: Tailwind usage\n<button className=\"px-4 py-2 bg-primary text-white rounded\">Save</button>\n```\n\n6. **Validation & Sanitization**\n   - All user input MUST be validated client-side (Zod) and server-side.\n   - *Rationale:* Prevents injection, data corruption, and ensures security.\n\n```typescript\n// MUST: Zod schema validation\nconst proposalSchema = z.object({\n  title: z.string().min(5),\n  content: z.string(),\n});\n```\n\n### MUST NOT Do\n\n1. **No Multi-Responsibility Files**\n   - MUST NOT combine multiple domains or unrelated logic in one file.\n\n```typescript\n// MUST NOT: Mixing domains\n// Contains both user auth and proposal logic\n```\n\n2. **No Implicit Any or Unchecked Types**\n   - MUST NOT use implicit any; always specify types.\n\n```typescript\n// MUST NOT: Implicit any\nfunction saveData(data) { ... } // Wrong\nfunction saveData(data: Proposal) { ... } // Correct\n```\n\n3. **No Direct State Mutation**\n   - MUST NOT mutate Zustand or React state directly; always use setters.\n\n```typescript\n// MUST NOT: Direct state mutation\nstore.state.value = 42; // Wrong\nstore.setState({ value: 42 }); // Correct\n```\n\n4. **No Business Logic in UI Components**\n   - MUST NOT place API calls or domain logic inside presentation components; delegate to hooks/services.\n\n```typescript\n// MUST NOT: API call in component body\nfunction ProposalEditor() {\n  fetch('/api/proposal'); // Wrong\n}\n```\n\n5. **No Hardcoded Secrets or Keys**\n   - MUST NOT commit secrets to codebase; use environment variables and Vercel/Supabase secret management.\n\n6. **No Unhandled Promise Rejections**\n   - MUST NOT ignore async errors; always use try/catch or .catch.\n\n```typescript\n// MUST NOT: Unhandled promise\napi.fetchData().then(data => { ... }); // Wrong\n// Correct\ntry { await api.fetchData(); } catch (e) { ... }\n```\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n- MUST adhere to domain-driven, layered architecture: presentation → application → domain → infrastructure.\n- Each domain module MUST contain its own types, services, and hooks.\n- Shared logic MUST be extracted to `shared` modules.\n\n```typescript\n// MUST: Domain module example\n/domains/proposal/\n  ProposalEditor.tsx\n  useProposal.ts\n  proposalService.ts\n  proposalTypes.ts\n```\n\n### Data Flow Patterns\n\n- Client-server communication MUST use RESTful JSON APIs via Axios or fetch, with react-query for caching and optimistic updates.\n- All server responses MUST follow a standard envelope: `{ data, error }`.\n- MUST use SWR/react-query for all data fetching; avoid useEffect for remote fetch.\n\n```typescript\n// MUST: react-query usage\nconst { data, error } = useQuery(['proposal', id], () => fetchProposal(id));\n```\n\n### State Management Conventions\n\n- MUST use Zustand for global state; local state via useState/useReducer.\n- Server state MUST be managed with @tanstack/react-query.\n- MUST NOT create custom global state solutions.\n\n```typescript\n// MUST: Zustand store\nimport { create } from 'zustand';\nconst useProposalStore = create(set => ({\n  proposals: [],\n  setProposals: (proposals) => set({ proposals }),\n}));\n```\n\n### API Design Standards\n\n- All API endpoints MUST be RESTful, stateless, and documented via OpenAPI 3.1.\n- MUST validate and sanitize all input (Zod/class-validator).\n- MUST implement RBAC and RLS for all data access.\n- Error responses MUST NOT expose internal implementation details.\n\n```typescript\n// MUST: API response envelope\nreturn c.json({ data: proposal, error: null });\n```\n\n```typescript\n// MUST NOT: Expose stack trace\nreturn c.json({ error: error.stack }, 500);\n```\n\n---\n\n# Example Code Snippets\n\n```typescript\n// MUST: Single-responsibility, typed function, error handling\nimport { z } from 'zod';\n\nconst proposalSchema = z.object({\n  title: z.string().min(5),\n});\n\nasync function createProposal(input: z.infer<typeof proposalSchema>): Promise<Proposal> {\n  try {\n    proposalSchema.parse(input);\n    const response = await api.post('/proposals', input);\n    return response.data;\n  } catch (error) {\n    Sentry.captureException(error);\n    throw new Error('Proposal creation failed');\n  }\n}\n```\n\n```typescript\n// MUST NOT: Mixed concerns and implicit any\nfunction handleUserAndProposal(data) { // Implicit any\n  // Handles both user and proposal logic - wrong\n}\n```\n\n```typescript\n// MUST: Zustand global state\nimport { create } from 'zustand';\n\ntype ProposalState = {\n  proposals: Proposal[];\n  setProposals: (proposals: Proposal[]) => void;\n};\n\nexport const useProposalStore = create<ProposalState>((set) => ({\n  proposals: [],\n  setProposals: (proposals) => set({ proposals }),\n}));\n```\n\n```typescript\n// MUST NOT: Direct mutation of state\nuseProposalStore.getState().proposals.push(newProposal); // Wrong\n// Use setProposals instead\n```\n\n```typescript\n// MUST: react-query data fetching\nconst { data, isLoading, error } = useQuery(['proposal', id], () => fetchProposal(id));\n```\n\n```typescript\n// MUST NOT: useEffect for remote data fetch\nuseEffect(() => {\n  fetchProposal(id).then(setProposal); // Wrong\n}, [id]);\n```\n\n---\n\n## 6. Quality Criteria\n\n- All code MUST be modular, typed, and domain-driven.\n- All error paths MUST be handled explicitly.\n- No secrets, business logic, or state mutations in UI components.\n- All APIs, data, and state MUST be validated and access-controlled.\n- Consistency, readability, and maintainability are top priorities.\n\n**This guideline is the single source of truth for all code in this project. All contributors MUST adhere strictly to these rules.**",
      "writedAt": "2025-07-07T14:20:03.894Z"
    }
  ]
}